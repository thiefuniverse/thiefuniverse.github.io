# csapp 缓冲区溢出攻击

[TOC]

[TIME:2024-12-19]
[TAG:assembly]

## 介绍
本文介绍csapp实验题中[attack bomb](https://csapp.cs.cmu.edu/3e/labs.html)的分析过程;该实验要求利用程序的缓冲区溢出漏洞和返回值优化漏洞,通过给予特定输入内容,来改变程序正常的运行逻辑，实现对程序的攻击操作;通过这个攻击过程增强学习者稳定性编码的意识、熟悉栈区数据的机制。其中给了两个待攻击的目标程序, ctarget（存在缓冲区溢出）和rtarget(存在返回值优化漏洞),和对应的5个具体攻击要求.


## level 1
第一题介绍了ctarget会类似如下的test函数，接收一个buf输入，需要让getbuf调用返回之后，不进行后续操作，直接调用touch1函数。
![intro](attack_lab/2.png)
gdb跑起来目标程序(ctarget),反汇编看下test和getbuf的实现。
![disassembly for test/getbuf](attack_lab/1.png)
从getbuf开始的反汇编中，看到rsp寄存器减去了0x28（40个字节），一般来说，应该是从栈上分配了40个字节的内存给局部变量，对应代码中的BUFFERSIZE，之后将rsp赋值给rdi，作为Gets的参数来接收数据。
之后我还看了下Gets的反汇编，但是想了想，Gets本身的作用是读取数据存储到buf，要想实现getbuf返回之后不继续执行原有逻辑，则需要在Gets读取的时候，让溢出数据覆盖栈上get\_buf的返回地址，通过改变返回地址，改变ip寄存器的行为。
观察调用getbuf时的栈数据，发现进入函数入口时rsp指针为 0x5561dca0，
![](attack_lab/5.png)
此时它对应栈上的数据是0x00401976,正是getbuf返回后的下一行地址。此处如果能让getbuf里缓存溢出修改当前这里的数据，就可以使得getbuf返回后跳转到touch1. 测试输入12345,发现0x5561dca0-0x28的位置，确实被修改成了12345（对应下图中的0x31 0x32 0x33 0x34 0x35）；现在问题转化为，要把touch1的函数地址，作为给getbuf的输入中的第41-44个byte的数据;
![observe stack data](attack_lab/1.png)
disas touch1获取到函数开始地址后(具体小端序表示为c0 17 40 00)，使用hex2raw 进行验证，发现确实通过了level1测试,验证成功。
![test](attack_lab/7.png)


## level 2
第二题增加了难度，具体如下,
![](attack_lab/3.png)

现在要求getbuf返回后跳转到touch2，且这个touch2存在一个unsigned的参数，一开始我想着很简单，以为把这里要求的cookie（一个unsigned数）作为rsp+4地址的数据写入(即追加到ret地址之后)，就可以作为调用touch2时的第一个外部参数被读取，然而验证失败了.
![](attack_lab/4.png)
阅读手册中的建议，发现这里实际touch2的第一个参数是通过rdi寄存器传递的，而不是通过rsp+4的栈数据传递；需要在getbuf返回的时候，将rdi寄存器设置为对应的cookie；问题来了，怎么通过栈溢出来修改rdi寄存器的值呢？让程序能完全按照这种极具自定义属性的逻辑运行，感觉可以通过缓冲区溢出，在栈的内存区域传递一段代码（包含给rdi赋值的逻辑）,然后在getbuf返回的时候，直接跳转到栈上我们代码的位置。不过对于这个办法来说，可能存在一个问题，就是栈区上传递A的数据可能不可执行,尝试验证试试。

![](attack_lab/11.png)
直接把栈的数据地址作为ret返回的地址，ret执行时直接触发了段错误，程序异常中断了。

苦思良久,不得其法。开始在网上找，发现一般防止栈溢出攻击，一个有力的措施就是让栈不可执行。找了一个其他人attack lab的分析，发现他level2的想法和我没什么区别。但是我的程序会崩溃（signal 11）,应该还是我这边环境的原因；网上找[怎么解决栈不可执行](),发现可以通过安装execstack 程序来检查栈执行状态并修改。

```shell
# 修改为栈可执行
execstack -s ./ctarget
```

检查发现ctarget确实是栈不可执行的，调整之后发现不再出现之前的段错误(signal 11),但是还是会在ret的时候段错误崩溃（和之前不一样,没有11的错误码）.目前我的注入代码部分，是把修改rdi寄存器的逻辑放在栈上40个byte的buffer之外，在返回地址的区域之后，加上了汇编的指令；40 byte数据+ret地址+注入代码(其中ret地址指向栈上注入代码的起始位置)，反复检查并调试了逻辑，直到ret执行（崩溃之前）感觉都没什么问题。但是问题依旧，还是崩溃，我甚至怀疑是不是我的汇编写的有问题，又确认了一遍手册中给的生成汇编的机械码的方法。

之后我又尝试直接把注入代码放到40个byte buffer的位置上，把ret地址改成buffer的栈位置,此时，发现通过了测试。

![注入代码放在buffer中通过测试](attack_lab/9.png)

很纳闷为啥必须放在这个buffer里，追加到ret地址之后到底有什么问题呢？ 于是继续删减调试ret地址之后的汇编部分，然后让我发现一个很奇怪的崩溃堆栈，堆栈里执行的函数地址是我修改后的，但是发现它有8个字节；由于调试时显示的地址都是4个字节就存储完了，让我遗漏了这一点(这是个64位的程序，指针占8字节)。

![ret指令从栈上pop了8byte的数据](attack_lab/8.png)

我把ret地址后面加4个00 补齐，之后再追加注入代码，确实也可以通过测试了！

![调整后通过测试](attack_lab/10.png)

然后，放在40byte的buffer里就正常，是因为这个时候传入的缓冲区数据，最后就是ret地址，它之后的数据碰巧是4个0(如果手动改成非0也一样会出现崩溃问题).简单来说，之前遇到的崩溃，是由于ret返回的地址，是个被认为不可正常访问的地址（没有补0引起）。


## level 3





